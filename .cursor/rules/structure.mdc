---
description: Code organization rules
globs:
alwaysApply: true
---

# Code Organization Rules

## Component Structure
- Always separate UI components from business logic
- UI components should only handle rendering and user interactions
- Business logic should be extracted into custom hooks
- Keep components focused on a single responsibility

## Hook Organization
- Create custom hooks for all business logic and state management
- Organize hooks by feature/domain in appropriate folders:
  - `hooks/login/` - Authentication-related hooks
  - `hooks/dashboard/` - Dashboard-related hooks
  - `hooks/api/` - API-related hooks
  - `hooks/ui/` - UI state management hooks
- Use descriptive hook names that clearly indicate their purpose
- Export hooks with clear, typed return values

## File Naming Conventions
- Hook files: `use-[feature-name].ts` (e.g., `use-logout.ts`, `use-session.ts`)
- Component files: descriptive names (e.g., `nav-user.tsx`, `login-form.tsx`)
- Keep file names lowercase with hyphens for separation

## Code Separation Guidelines
When creating or modifying components:

1. **Identify business logic** - Look for:
   - API calls and data fetching
   - State management
   - Event handlers with complex logic
   - Navigation logic
   - Form validation
   - Authentication flows

2. **Extract to hooks** - Move business logic to custom hooks:
   - State variables and setters
   - useEffect hooks
   - Async functions
   - Event handlers with business logic
   - API integration code

3. **Keep components clean** - Components should only contain:
   - JSX/TSX markup
   - Hook calls
   - Simple event handlers that call hook functions
   - UI-related state (if minimal)

## Example Pattern
```typescript
// ❌ Don't do this - mixing UI and business logic
function MyComponent() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    fetchData();
  }, []);
  
  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/data');
      const result = await response.json();
      setData(result);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };
  
  return <div>{/* UI markup */}</div>;
}

// ✅ Do this - separated concerns
// hooks/use-data.ts
export function useData() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const fetchData = async () => {
    setLoading(true);
    try {
      const response = await fetch('/api/data');
      const result = await response.json();
      setData(result);
    } catch (error) {
      console.error(error);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchData();
  }, []);
  
  return { data, loading, fetchData };
}

// components/MyComponent.tsx
function MyComponent() {
  const { data, loading } = useData();
  
  return <div>{/* UI markup */}</div>;
}
```

## When to Apply This Rule
- Creating new components
- Refactoring existing components
- Adding new features to components
- Reviewing code for maintainability

## Benefits
- Improved testability
- Better code reusability
- Cleaner component code
- Easier maintenance
- Consistent codebase structure
